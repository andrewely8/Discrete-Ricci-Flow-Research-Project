We are trying to take a graph of nodes and edges and detect communities within the graph. A community is a group of nodes that interact with each other more so than nodes in other communities. If we have a social media app and nodes represent users, and edges represent a stream of messages between two users, then if we examine a region like an entire state, we may realize communities like individual townships, or individual friend groups. Friend groups will have more densely populated edges between the nodes in the friend group than nodes across different friend groups. 

Algorithms that did this existed, but this paper presents a new algorithm that involves Ricci flow by considering graphs to be geometric objects and applying Ricci flow to decompose the graph into communities. This new geometric based algorithm has competitive results compared to other algorithms that have already existed. So, this geometric approach seems to indeed work.

There is something called topological connect sum decomposition of 3-manifolds. The graph network is considered a discrete counterpart of a manifold (3-manifolds) and connected sum components a counterpart of a community. The concept of geometric curvature describes quantitatively how spaces are bent at each point. Regions in a space with large positive curvature tend to be more densely packed than regions of negative curvature. Ricci flow deforms the space in a way that locates these regions of large curvature. Applying Ricci flow causes regions in space of large positive curvature to shrink, while regions of very negative curvature spread out. Communities in networks resemble these regions in manifolds that have large positive curvature. So, we apply the discrete Ricci flow on networks similar to how the classic Ricci flow is applied on manifolds, and we detect community structures. 

So, if we have a manifold, which is like a 3D shape, we can apply classical Ricci flow to the shape, and it will smooth out the shape. Through this process, a singularity forms, which is a point on the shape that cannot be smoothed anymore. Then we cut the shape at this singularity and are left with two different shapes of positive curvature. The analogy is that if we have a graph of nodes and edges, we can apply discrete Ricci flow to the graph, and it will stretch edges of large negative curvature and shrink edges of large positive curvature. Then we can remove edges of length greater than a set threshold, which splits the graph into communities that have large positive curvature.


We need to use the optimal transport theory. Metric graphs assume a probability measure for each node and the Ricci curvature of an edge is related to the optimal transportation cost between two probability measures defined on the vertices of the edge. 

The name of the algorithm is "Discrete Ricci Flow on networks, for detecting community structures" (the algorithm this paper is about/created). This algorithm is defined on weighted graphs and it deforms edge weights over iterations. Edges of large positive Ricci curvature (sparsely traveled edges) will shrink, and edges of very negative Ricci curvature (heavily traveled edges) will be stretched. Over many iterations, heavily traveled edges are detected, and removing them or cutting across them creates communities. 

If we have a graph with nodes and edges where an edge will be weight 1 (unweighted graph, or uniformly weighted graph of all weights being 1), our edge weights evolve over iterations of the algorithm. So, we need to decide how many iterations of the algorithm to run, which will transform the edge weights of the graph to have quantifiable curvature (by how positive or  how negative), then we need to decide at what edge weight do we want to cut the edge, to form the communities. So we need to decide how many iterations to run, and a threshold for when an edge gets cut.

The algorithm was tested on networks generated by the stochastic block model (SBM), the Lancichinetti-Fortunato-Radicchi (LFR) benchmark graph, and the emergent geometrical network model (GNet). The metrics in which the algorithm was assessed was the Adjusted Rand Index (ARI) as a quality measure for the clustering accuracy. They also assessed it with other metrics, one mentioned was modularity. 

Other mentioned applications of this type of algorithm (Discrete Ricci Flow) have been for anomaly detection, and for network alignment (noisy graph matching). 

We have the concept of curvature. This is a quantitative measure of how space is curved. For a surface in the 3D Euclidean space, the curvature at a point is defined as the signed area distortion of the Gauss map sending a point on the surface to its unit normal vector. For example, a plane has zero curvature, a sphere has positive curvature, and a hyperboloid of one sheet has a negative curvature. The curvatures depend only on the induced Riemannian metric on the surface, independent of how a surface is embedded in the 3D space. So, curvature can be measured just from the distances and local changes of points. This is the key framework that allows us to see a graph of nodes and edges as geometrical curvature. Now we can discretely encode curvature in graphs. 

A further "analogy": A positive curved region in 3D space tends to have a small diameter and is geometrically crowded like a sphere. A negative curved region tends to have distances that spread apart exponentially like a hyperbolic space. So, we can say that a positive curved space is like a community, where nodes are drawn together and overlap more, whereas a negative curved space is like a tree, where neighborhoods expand rapidly and the graph is sparse with no communities. So we are interested in positive curved regions of our graph during the algorithm for community detection.

We also see a bridge between Ricci curvature and optimal transportation. Ricci curvature assigns each unit tangent vector at a point a scalar value, which is the average of the sectional curvatures of planes containing that unit tangent vector. Geometrically, Ricci curvature controls how fast the volume of a ball grows as a function of the radius, as well as the volume of the overlap of two balls in terms of their radii and the distance between their centers. The volume of the overlap of two balls is directly related to the cost of transporting one ball to the other. A large volume overlap means the transportation will cost less. So we make the connection between Ricci curvature and optimal transportation. We have explicit formulas for this.  

We have the optimal transportation problem. We have two probability spaces X, Y. We need to move u items and v items will be consumed, we have two probability Borel measures u,v. We define the cost of transporting from location x to location y to be c(x,y), where c: X × Y , mapping to a non negative real number. We can take the cost function c to be the distance d(x,y) if X=Y and take the cost of transporting per unit distance as constant. A transportation T:(X,u) maps to (Y,v) is a measure preserving map. The optimal transportation problem is the find a T:X->Y that realizes: inf{integral_X( c(x, T(x))du(x)|T: transportation}. This problem can be formulated into a linear optimization problem. The transportation maps T can be replaces by probability measures γ on X × Y, called transportation plans. These satisfy γ(A×Y) = u(A) and γ(X×B) = v(B) for all subsets A and B. The goal is to find a transportation plan γ that attains the infimum cost: W(u,v) = inf{integral_X×Y(c(x,y)dγ(x,y)|γ E Γ(u,v)}, where  Γ(u,v) denotes the collection of all possible transportation plans. If X is a metric space with distance function d and X=Y, then the quantity W(u,v) for c(x,y)=d(x,y) is called the Wasserstein distance between two probability measures u,v on X.

Wassertstein distance comes into play like this: If (M^n,d) is an n-dimensional manifold with volume u and a fixed ε > 0 , let m_x = (u|B(x,ε))/(u(B(x,ε))) be the probability measure associated to x in M where B(x,ε) is the ball of radius ε at x. Then the Wasserstein distance W(m_x,m_y)  = (1-k(x,y))*d(x,y) where: (EQUATION 1**) k(x,y) = (ε^2 * Ricci(v,v))/(2(n+2)) + O(ε^3 + ε^2 *d(x,y)). v is the tangent vector at x of the geodesic xy. This shows that Ricci curvature can be defined for general metric spaces with measures. Given a metric space (X,d) with a probability measure m_x for each x in X, the Olliviers Ricci curvature along the path xy is defined to be: k_xy = 1 - (W(m_x,m_y))/(d(x,y)), where W(m_x,m_y) is the Wasserstein distance with respect to c(x,y) = d(x,y).

Now we can introduce Ricci flow. This deforms the metric of a manifold in a way that smooths out the irregularities in the metric. Suppose we have a metric g_ij given on a manifold M so that it Ricci curvature is R_ij. We have the Ricci Flow given by:(∂/∂t)g_ij = -2R_ij. A solution to the Ricci Flow is a one-parameter family of metrics g_ij(t) on a smooth manifold M that satisfies the partial differential equation. The crucial thing that Ricci flow does it evolve the curvature such that it smooths out irregularities of the curvature. Regions of the manifold with positive curvature tend to shrink while regions of negative curvature tend to expand. Singularities emerge during this process as small neighborhoods of a surface in the 3-manifold. By removing the singularities, we capture the decomposition of the 3-manifold. 

So, now we can relate all of this to graphs and community detection. A network is analogous to a discretization of manifolds and communities in the network are analogous to the components in the geometric decomposition of the manifold. A discrete Ricci Flow on the network should be able to detect the community structure.

And after we have these analogies mapped out, we can now take a graph G=(V,E,w) and define a m_x mass distribution metric for each node x on x's neighbor nodes. We have a transport plan as A: VxV -> [0,1] such that A(u,v) is the amount of mass at vertex v to be moved to vertex u. Now we take the Wassertstein distance to be W(m_x,m_y) = inf(sum_u,v in V (A(u,v)d(u,v))). The discrete Ricci curvature on a network edge xy in E is defined as: k_xy = 1- (W(m_x,m_y))/(d(x,y)), where d(x,y) is the length of the shortest path between nodes x and y. Now, finally we can say that if nodes x and y are from different communities, their neighbor nodes tend to have fewer common neighbors, and the best way to move m_x from x's neighbors to m_y in y's neighbors is to travel along the xy edge. So, the Wasserstein distance is necessarily larger than the length xy, leading to negative Ricci curvature. For nodes in same communities, they will have a Wasserstein distance no greater then d(x,y) since the shortest path will come from a path within that community. So, intra-community edges are mostly positively curved. And now we can detect the communities. 

One key note is that we need to define m_x for x in V. We use a family of probability distrubtions m_x^a,p with a on [0,1] and p >= 0. m_x^a,p(x_i) = a if x_i = x , (1-a * exp(-d(x,x_i)^p)/C if x_i in pi(x) , 0 otherwise. C is the sum of exp(-d(x,x_i)^p) for all x_i in pi(x). Where C is a normalization factor and pi(x) is the set of neighbors of x. The parameter a determines the probability to remain at x. The power parameter p determines how much we want to discount the neighbor of x_i of x with respect to the weight d(x,x_i). When p is 0 the probability measure is uniform on all neighbors of x. For lare p, the neighbors that are far away from x are aggressively discounted. 

We perform iterations of this algorithm, and we update edge weights by w_xy^(i+1) = d^(i)(x,y)-k_xy^(i) * d^(i)(x,y), where the weight w_xy^(i) is the edge weight xy at the i-th iteration and k_xy^(i) is the Ricci curvature at the edge xy athe ith iteration, and d^(i)(x,y) is the shortest path distance on the graph induced by the weights. 

Finally, we set a thresholding value that will be used to separate the communities based on edge weights greater than the threshold after we perform a decided number of iterations. 





Note sheet plan:
-Describe the problem at hand with a graph
-Summarize the paper in very simple terms and high-level perspective.
-Describe all the analogies at a high-level perspective.
-Show the mathamatical transformation of the analogies.
-Show a worked example of running the algorithm.
-List many questions at the end:
   -Ricci Flow?
   -mention of other applications of geometric apporaches to graphs, can we find new 
    ones reasonably easily?
   -can we find more conclusive or broader metric testing?
   -There are many choices to make for input into the algorithm. Can we generalize or 
    deterministically compute any of them?
-List a potential roadmap for persuring a project directly related to this:
   -First I will implement the algorithm in python such that it runs for any defined input of G={V,E} , iterations to run, and other decisions.
   -I will test the implementation against the datasets used in the paper to make sure my algorithm is correct.
   -I will test the implemntation against many more datasets and try to find edge cases, or performence concerns.
   -I will try to find a way to generalize some of the input values so they can be 
    deterministically calculated instead of inputted by choice.
   -I will try to 
